using System; // Підключаємо базові типи .NET (Exception, Action)
using System.Collections.Concurrent; // Підключаємо thread-safe чергу для передачі дій з мережевого потоку в головний

namespace CoopSpectator.Infrastructure // Оголошуємо простір імен для інфраструктурних утиліт моду
{ // Починаємо блок простору імен
    /// <summary> // Описуємо призначення класу для документації
    /// Безпечний диспетчер для виконання дій в головному потоці гри. // Пояснюємо що клас робить
    /// </summary> // Завершуємо блок XML-коментаря
    public static class MainThreadDispatcher // Оголошуємо статичний клас, бо диспетчер має бути глобальним для моду
    { // Починаємо блок класу
        private static readonly ConcurrentQueue<Action> _actions = new ConcurrentQueue<Action>(); // Зберігаємо чергу дій, які треба виконати в головному потоці

        /// <summary> // Описуємо метод для документації
        /// Додає дію в чергу на виконання в головному потоці. // Пояснюємо призначення
        /// </summary> // Завершуємо XML-коментар
        /// <param name="action">Дія, яку потрібно виконати в головному потоці</param> // Документуємо параметр
        public static void Enqueue(Action action) // Оголошуємо публічний метод, щоб будь-який потік міг поставити дію в чергу
        { // Починаємо блок методу
            if (action == null) // Перевіряємо параметр на null, щоб не кидати виняток у ConcurrentQueue
            { // Починаємо блок if
                return; // Виходимо, бо нічого ставити в чергу
            } // Завершуємо блок if

            _actions.Enqueue(action); // Додаємо дію в thread-safe чергу
        } // Завершуємо блок методу

        /// <summary> // Описуємо метод для документації
        /// Виконує всі накопичені дії; викликається з головного потоку (наприклад, в OnApplicationTick). // Пояснюємо коли викликати
        /// </summary> // Завершуємо XML-коментар
        public static void ExecutePending() // Оголошуємо метод виконання накопичених дій
        { // Починаємо блок методу
            Action action; // Оголошуємо змінну для отриманої з черги дії

            while (_actions.TryDequeue(out action)) // Поки у черзі є дії, дістаємо їх по одній
            { // Починаємо блок while
                try // Починаємо блок try, щоб помилка в одній дії не зупинила виконання інших
                { // Починаємо блок try
                    action(); // Виконуємо дію в головному потоці
                } // Завершуємо блок try
                catch (Exception ex) // Ловимо будь-які винятки, щоб не крашнути гру через один callback
                { // Починаємо блок catch
                    ModLogger.Error("Помилка під час виконання дії з MainThreadDispatcher.", ex); // Логуємо помилку для дебагу
                } // Завершуємо блок catch
            } // Завершуємо блок while
        } // Завершуємо блок методу
    } // Завершуємо блок класу
} // Завершуємо блок простору імен

